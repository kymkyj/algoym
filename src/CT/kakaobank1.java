/*

// 카카오뱅크 1번

문제 설명
민수는 12월 31일이 만기일인 자유 적립식 적금에 돈을 저축하고 있습니다. 입금 시점에 따라 다른 금리가 적용될 수 있으며, 입금일로부터 만기일(12월 31일)까지 남은 날짜 수를 일할 계산하여 이자를 결정합니다. 아래는 민수의 입금 내역을 바탕으로 이자를 계산한 표입니다.

입금일	1년 금리(%)	입금액(원)	12/31까지 남은 날짜 수	결정 이자(소수점 이하는 버림)
01/01	2	50000	364	(50000 X 0.02) X (364 / 365) ≒ 997
01/03	1	999	362	(999 X 0.01) X (362 / 365) ≒ 9
01/31	9	10000	334	(10000 X 0.09) X (334 / 365) ≒ 823
02/05	5	6547	329	(6547 X 0.05) X (329 / 365) ≒ 295
02/05	6	1	329	(1 X 0.06) X (329 / 365) ≒ 0
06/30	5	5000	184	(5000 X 0.05) X (184 / 365) ≒ 126
10/15	5	2529	77	(2529 X 0.05) X (77 / 365) ≒ 26
12/30	4	10000	1	(10000 X 0.04) X (1 / 365) ≒ 1

윤년은 존재하지 않고, 1년은 무조건 365일이라고 간주합니다.
같은 날짜에 입금하더라도, 금리는 다를 수 있습니다.
01/01부터 12/31까지는 364일이 남았으므로, 1년 이자(50000 X 0.02)에 (364 / 365)를 곱한 값이 결정 이자가 됩니다.
10/15부터 12/31까지는 77일이 남았으므로, 1년 이자 (2529 X 0.05)에 (77/365)를 곱한 값이 결정 이자가 됩니다.
(2529 X 0.05) X (77 / 365) = 26.6756...
결정 이자는 26원입니다. 소수점 이하는 반올림하지 않고, 버리는 것에 유의해야 합니다.
12/30부터 12/31까지는 1일이 남았으므로, 1년 이자 ( 10000 X 0.04)에 (1 / 365)를 곱한 값이 결정 이자가 됩니다.
민수가 12/31에 받게 되는 만기 수령액은 아래와 같이 계산됩니다.
원금 = 50000 + 999 + 10000 + 6547 + 1 + 5000 + 2529 + 10000 = 85076
이자 = 997 + 9 + 823+ 295 + 0 + 126 + 26 + 1 = 2277
만기 수령액 = 원금 + 이자 = 85076 + 2277 = 87353
민수의 입금 내역을 담은 배열 deposits이 매개변수로 주어집니다. 이때, 민수가 12/31에 받게 되는 만기 수령액을 return 하도록 solution 함수를 완성해주세요.

제한사항
deposits의 길이(=입금 내역의 개수)는 1 이상 1,000 이하입니다.
deposits의 원소들은 입금 날짜가 빠른 것부터 오름차순으로 정렬되어 있습니다.
deposits의 각 원소는 "MM/DD R MONEY" 형식의 문자열입니다.
MM/DD는 01/01부터 12/30까지이며, 입금 날짜를 나타냅니다.
12/31은 만기일으므로, 입금 날짜로는 주어지지 않습니다.
윤년은 존재하지 않는다고 가정했으므로, 02/29는 입금 날짜로 주어지지 않습니다.
13/15, 05/32 등처럼 잘못된 날짜는 입력으로 주어지지 않습니다.
1/1, 5/25, 11/7, 12:12 등처럼 5자리의 MM/DD형식을 맞추지 않은 날짜는 입력으로 주어지지 않습니다.
R은 1년 금리(Rate of interest)를 나타내며, 1 이상 9 이하입니다.
즉, 금리는 1% 이상 9% 이하이며, 소수점 이하는 입력으로 주어지지 않습니다.
MONEY는 입금액을 나타내며, 1 이상 99999 이하입니다.
따라서, MONEY의 자릿수는 1 이상 5 이하입니다.
MM/DD, R, MONEY는 하나의 공백(스페이스)으로 구분되어 있습니다.
입출력 예
deposits	result
["01/01 2 50000", "01/03 1 999", "01/31 9 10000", "02/05 5 6547", "02/05 6 1", "06/30 5 5000", "10/15 5 2529", "12/30 4 10000"]	87353
["03/01 5 15000", "05/15 2 9527", "11/30 9 10000"]	35349
입출력 예 설명
입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2

입금일	1년 금리(%)	입금액(원)	12/31까지 남은 날짜 수	결정 이자(소수점 이하는 버림)
03/01	5	15000	305	(15000 X 0.05) X (305 / 365) ≒ 626
05/15	2	9527	230	(9527 X 0.02) X (230 / 365) ≒ 120
11/30	9	10000	31	(10000 X 0.09) X (31 / 365) ≒ 76
민수가 12/31에 받게 되는 만기 수령액은 아래와 같이 계산됩니다.
원금 = 15000 + 9527 + 10000 = 34527
이자 = 626 + 120 + 76 = 822
만기 수령액 = 원금 + 이자 = 34527 + 822 = 35349




// 카카오뱅크 2번

    문제 설명
로봇을 이용하여 여러 종류의 완제품을 만드는 공장을 운영하려고 합니다. 로봇 한 대는 부품 한 종류만 처리할 수 있으며, 완제품의 종류에 따라 필요한 부품이 다를 수 있습니다. 이때, 로봇 r대로 최대한 다양한 완제품을 만들려 합니다.

예를 들어, 각 완제품을 만들 때 다음과 같은 부품이 필요하고, 살 수 있는 로봇은 최대 두 대라고 가정하겠습니다(번호는 0번부터 시작합니다).

완제품 번호	필요한 부품 번호
0	0
1	0, 1
2	0, 1
3	0, 2
4	0, 1
5	1, 2
두 로봇을 이용해 완제품을 만드는 경우는 모두 다음과 같습니다.

구매할 첫 번째 로봇	구매할 두 번째 로봇	만들 수 있는 완제품
부품 0을 처리하는 로봇	부품 1을 처리하는 로봇	0, 1, 2, 4번 완제품
부품 0을 처리하는 로봇	부품 2를 처리하는 로봇	0, 3번 완제품
부품 1을 처리하는 로봇	부품 2를 처리하는 로봇	5번 완제품
따라서, 최대한 다양한 완제품을 만들려면 부품 0을 처리하는 로봇과 부품 1을 처리하는 로봇을 구매해야 합니다.

완제품을 만드는 데 필요한 부품의 정보 needs와 최대로 구매 가능한 로봇 수 r이 매개변수로 주어질 때, 최대 몇 종류의 완제품을 만들 수 있는지 return 하도록 solution 함수를 완성해 주세요.

제한사항
needs의 세로(행) 길이는 1 이상 1,000 이하입니다.
세로(행) 길이는 만들 수 있는 완제품의 개수를 나타냅니다.
행 번호는 완제품의 번호를 의미하며, 0번부터 시작합니다(0행 → 0번 완제품, 1행 → 1번 완제품 ...).
needs의 가로(열) 길이는 1 이상 15 이하입니다.
열 번호는 부품 번호를 의미하며, 0번부터 시작합니다.
needs의 모든 원소는 0 또는 1 입니다.
needs[x][y] 값이 1이면 x번 물건을 만드는데 y번 부품이 필요하다 의미입니다.
needs[x][y] 값이 0이면 x번 물건을 만드는데 y번 부품이 필요 없다는 의미입니다.
번호가 가로(열) 길이 이상인 부품은 모두 필요 없는 것으로 가정하면 됩니다.
예를 들어, 가로(열) 길이가 3인 경우 0번 ~ 2번 부품에 대한 정보가 주어지며, 3보다 큰 번호의 부품은 모두 필요 없는 것으로 가정하면 됩니다.
r은 1 이상 needs의 가로(열) 길이 이하인 자연수입니다.
입출력 예
needs	r	result
[ [ 1, 0, 0 ], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1] ]	2	4
입출력 예 설명
입출력 예 #1

앞서 설명한 예시와 같습니다.



카카오뱅크 3번

문제 설명
'위대한 상인' 게임에서는 n일 동안 '신비한 돌'을 사고팔아 시세 차익을 최대화해야 합니다. '신비한 돌'은 매일 시세가 달라질 수 있습니다.

게임의 규칙은 다음과 같습니다.

하루에 최대 하나의 돌만 살 수 있습니다.
하루에 팔 수 있는 돌 수에는 제한이 없지만, 가지고 있는 만큼만 팔 수 있습니다.
플레이어는 처음에 돈과 '신비한 돌'을 가지고 있지 않습니다.
n일 중에 '신비한 돌'의 시세가 0인 날이 반드시 있습니다.
예를 들어, 3일간 '신비한 돌'의 시세가 [0, 1, 2]라고 하겠습니다. 첫째 날 돌을 사서, 셋째 날 돌을 팔면 차익이 2로 최대가 됩니다.

기간의 길이 n, n일 동안의 '신비한 돌'의 시세가 담긴 배열 price가 매개변수로 주어집니다. '신비한 돌'을 사고팔아 낼 수 있는 최대 차익을 return 하도록 solution 함수를 완성해주세요. 만약 차익을 낼 수 없다면 0을 return 해주세요.

제한사항
n은 1 이상 100 이하인 정수입니다.
price의 길이는 n입니다.
price의 원소('신비한 돌'의 시세)는 0 이상 100 이하인 정수입니다.
'신비한 돌'의 시세가 0인 날이 반드시 있습니다.
입출력 예
price	result
[0,1,2]	2
[1,0,0]	0
[0,2,1,1,2]	4
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

첫째 날에는 돈이 없어 돌을 살 수 없습니다. 둘째 날과 셋째 날에는 돌을 살 수 있습니다. 하지만 돌을 팔아서 돈을 벌 수 없기 때문에 차익을 낼 수 없습니다.

입출력 예 #3

첫째 날 : 돌 0원에 구매(남은 돈 0원)
둘째 날 : 돌을 팔아 2원 획득(남은 돈 2원)
셋째 날 : 돌을 1원에 구매(남은 돈 1원)
넷째 날 : 돌을 1원에 구매(남은 돈 0원)
다섯째 날 : 돌을 2원에 전부 판매(남은 돈 4원)
따라서 돌을 사고팔아 남길 수 있는 최대 차익은 4원입니다.




카카오뱅크 4번

문제 설명
복잡한 연산을 빠르게 처리하기 위해 연산을 N개로 나누어 병렬적으로 처리하기로 하였습니다.
연산에는 이전 단계의 계산 값이 나와야만 다음 단계가 가능한 연산과, 동시에 진행해도 상관없는 연산이 있으므로 병렬 프로그래밍으로 연산을 처리하면 훨씬 일을 빠르게 처리할 수 있습니다.
각 연산별 수행시간 리스트 T, 종속되어 있는 연산들의 관계 R이 주어집니다. N개로 나눈 연산을 각각 1,2,3,...,K,...N번 연산이라고 할 때, K번 연산이 가장 빨리 끝나는 시점을 반환하는 함수를 완성해 주세요.

제한사항
수행시간 리스트 T의 각 원소는 1,000 이하의 자연수로 이루어져 있습니다. (각 원소는 1번 연산, 2번 연산...N번 연산의 수행 시간을 의미합니다.)
수행시간 리스트 T의 원소 개수 N은 2 이상 1,000 이하의 자연수 입니다.
연산들의 관계 R의 각 원소는 [Si, Ei] 로 이루어져 있으며, Si번째 연산이 끝나야 Ei번째 연산을 할 수 있다는 의미입니다. (단, Si와 Ei는 같지 않고, 1보다 크거나 같고, T보다 작거나 같은 자연수입니다.)
연산들의 관계 R의 원소 개수는 200,000 이하의 자연수 입니다.
K번 연산은 리스트 T의 원소 개수 N보다 작거나 같은 자연수입니다.
입출력 예
T	R	K	결과
[5,8,3,7,10,5,4]	[[1,2],[2,4],[1,4],[6,5],[3,5],[4,6]]	5	35
입출력 예 설명
입출력 예 #1
5번 연산을 수행하기 위해서는 1->2, 2->4, 1->4, 4->6, 6->5, 3->5의 과정이 존재합니다. 먼저 4번 연산이 선행이 되어야 하는데, 4번 연산을 수행하기 위해서는 1->2, 2->4 연산을 수행해야 하므로 1번, 2번, 4번 연산을 수행하는 시간 5+8+7이 소요됩니다. 다음, 4->6 연산을 수행하므로 6번 연산을 수행하는 시간 5가 수행됩니다. (4번 연산은 수행 완료 되었으므로 중복하여 더하지 않습니다.) 마지막으로 6->5, 3->5 연산을 수행해야 하지만, 6->5의 연산을 하는 동안 3->5의 연산은 끝나기 때문에 둘 중 값이 더 큰 6->5 연산. 즉 5번 연산을 수행하는 시간 10을 더합니다. (6번 연산은 수행 완료 되었으므로 중복하여 더하지 않습니다.) 결과적으로 5+8+7+5+10=35의 시간이 5번 연산이 가장 빨리 끝나는 시점입니다.




카카오뱅크 5번

문제 설명
중고차 딜러가 중고차를 사고 팔아 이익을 내려 합니다. 중고차는 매일매일 가격이 변하며, 그 날의 중고차 가격으로만 거래할 수 있습니다. 중고차 딜러는 앞으로 N일 동안의 중고차 가격을 예측했으며, 각 날짜별로 중고차를 구매했을 때 이익을 낼 수 있는 날짜가 며칠씩 있는지 구해보려 합니다.

다음은 10일 동안의 중고차 가격을 나타낸 예시입니다.

날짜	1일	2일	3일	4일	5일	6일	7일	8일	9일	10일
가격(원)	5	3	7	9	5	2	4	9	10	6
예를 들어 1일에 중고차를 구입할 경우 (3일, 4일, 8일, 9일, 10일)중 하루에 중고차를 팔면 이익을 낼 수 있습니다. 또 다른 예로 4일에 중고차를 구매한다면 이익을 낼 수 있는 날짜는 9일 하루 뿐 입니다.

앞으로 N일 동안의 중고차 가격이 들어있는 배열 prices가 매개변수로 주어질 때, 각 날짜별로 중고차를 샀을 경우, 앞으로 중고차를 팔아서 이익을 낼 수 있는 날짜는 며칠씩인지 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
prices의 길이는 2 이상 300,000 이하입니다.
prices의 원소는 1 이상 100,000,000 이하인 자연수입니다.
입출력 예
prices	result
[5, 3, 7, 9, 5, 2, 4, 9, 10, 6]	[5, 7, 3, 1, 3, 4, 3, 1, 0, 0]
[5, 4, 3, 2, 1, 2, 3, 4, 5]	[0, 1, 2, 3, 4, 3, 2, 1, 0]
입출력 예 설명
입출력 예 #1

1일에 중고차를 구입할 경우 (3일, 4일, 8일, 9일, 10일)의 거래 가격이 더 높으므로 이날 팔게되면 이익을 낼 수 있습니다. 모든 날짜에 대해 이익을 낼 수 있는 날짜 수를 구하면 [5, 7, 3, 1, 3, 4, 3, 1, 0, 0]이 됩니다.

입출력 예 #2

1일에 중고차를 구입할 경우, 이후 더 높은 가격에 거래 되는 날짜는 없으므로 이익을 낼 수 있는 날짜는 총 0일이 됩니다. 모든 날짜에 대해 이익을 낼 수 있는 날짜 수를 구하면 [0, 1, 2, 3, 4, 3, 2, 1, 0]이 됩니다.



카카오뱅크 SQL 1번

문제 설명
테이블 레이아웃

KKB_GOODS_S

NAME	TYPE	PK	NULLABLE	COMMENT
GOODS_CD	VARCHAR(4)	Y	NOT NULL	상품코드
SALE_YM	VARCHAR(6)	Y	NOT NULL	판매년월
SALE_CNT	NUMBER(10, 0)		NOT NULL	판매갯수
문제

KKB_GOODS_S 테이블은 특정 상품의 월별 판매량(개수)을 집계하여 보관하는 테이블입니다.
KKB_GOODS_S 테이블의 구조는 아래와 같습니다.

테이블

NAME	TYPE	PK	NULLABLE	COMMENT
GOODS_CD	VARCHAR	Y	NOT NULL	상품코드
SALE_YM	VARCHAR	Y	NOT NULL	판매년월
SALE_CNT	NUMBER		NOT NULL	판매개수
문제

현재 취급하고 있는 상품은 상품코드 0001 ~ 0005 까지 총 5개의 상품입니다. 5개의 상품판매 실적이 아래 형식대로 조회되도록 SQL을 작성해 주세요.
판매년월 오름차순 기준으로 조회되도록 작성해 주세요.
예시)

판매갯수

판매년월	상품0001판매개수	상품0002판매개수	상품0003판매개수	상품0004판매개수	상품0005판매개수	전체판매개수
202101	10	0	15	20	5	50
202102	0	0	0	5	10	15
202103	10	10	10	20	20	70


카카오뱅크 SQL2번

문제 설명
테이블 레이아웃

KKB_ACNO_TX

NAME	TYPE	PK	NULLABLE	COMMENT
ACNO	VARCHAR(9)	Y	NOT NULL	계좌번호
TX_DT	VARCHAR(8)	Y	NOT NULL	거래일자
TX_SEQ	NUMBER(5, 0)	Y	NOT NULL	거래번호
TX_AMT	NUMBER(15, 0)		NOT NULL	거래금액
TX_TM	VARCHAR(6)		NOT NULL	거래시각
TX_AF_BAL	NUMBER(15, 0)		NOT NULL	거래후잔액
TX_CD	VARCHAR(7)		NOT NULL	거래구분
문제지문

KKB_ACNO_TX 테이블은 특정 계좌의 일자별 거래내역을 담고 있는 테이블입니다.
KKB_ACNO_TX 테이블 및 해당 테이블에 생성되어 있는 인덱스 구조는 아래와 같습니다.

테이블

NAME	TYPE	PK	NULLABLE	COMMENT
ACNO	VARCHAR	Y	NOT NULL	계좌번호
TX_DT	VARCHAR	Y	NOT NULL	거래일자
TX_SEQ	NUMBER	Y	NOT NULL	거래번호
TX_AMT	NUMBER		NOT NULL	거래금액
TX_TM	VARCHAR		NOT NULL	거래시각
TX_AF_BAL	NUMBER		NOT NULL	거래후잔액
TX_CD	VARCHAR		NOT NULL	거래구분
인덱스

INDEX_NAME	INDEX_COLUMN
PK_T_ACNO_TX	ACNO + TX_DT + TX_SEQ
문제

계좌번호(ACNO), 거래일자(TX_DT)별 최종 거래(마지막 거래)의 거래후잔액(TX_AF_BAL)을 조회하는 쿼리를 작성해 주세요.
계좌번호(ACNO), 거래일자(TX_DT) 오름차순 기준으로 조회되도록 작성해 주세요.
예시)
아래와 같이 KKB_ACNO_TX 테이블에 데이터가 담겨 있다면,

ACNO	TX_DT	TX_SEQ	TX_AMT	TX_TM	TX_AF_BAL	TX_CD
330000001	20200307	1	10000	110000	10000	입금
330000001	20200307	2	5000	121000	5000	출금
330000001	20210101	1	3000	100000	8000	입금
330000002	20210201	1	20000	090101	20000	입금
330000002	20210501	1	30000	111517	50000	입금
330000002	20210501	2	15000	121000	35000	출금
계좌의 일자별 최종 거래후잔액은 아래와 같이 조회되어야 합니다.

ACNO	TX_DT	TX_SEQ	TX_AF_BAL
330000001	20200307	2	5000
330000001	20210101	1	8000
330000002	20210201	1	20000
330000002	20210501	2	35000

 */